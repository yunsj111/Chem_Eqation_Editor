import streamlit as st
from typing import List, Dict, Optional, Tuple
import networkx as nx
from rdkit import Chem
import sys
import os

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏Î•º Python Í≤ΩÎ°úÏóê Ï∂îÍ∞Ä
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from models.molecule import Molecule
from models.atom import Atom, AtomType, AtomQuery
from models.bond import Bond, BondType, BondQuery
from components.drawing.utils import validate_smarts

class SmartsGenerator:
    """SMARTS Ìå®ÌÑ¥ ÏÉùÏÑ±Í∏∞"""

    def __init__(self):
        pass

    def generate_smarts_from_molecule(self, molecule: Molecule) -> str:
        """Î∂ÑÏûê Í∞ùÏ≤¥ÏóêÏÑú SMARTS Ìå®ÌÑ¥ ÏÉùÏÑ±"""
        if not molecule.atoms:
            return ""

        try:
            # NetworkX Í∑∏ÎûòÌîÑÎ°ú Î≥ÄÌôò
            graph = molecule.to_networkx()

            # Ïó∞Í≤∞ Ïª¥Ìè¨ÎÑåÌä∏Î≥ÑÎ°ú Ï≤òÎ¶¨
            components = list(nx.connected_components(graph))
            smarts_parts = []

            for component in components:
                if len(component) == 1:
                    # Îã®Ïùº ÏõêÏûê
                    atom_id = list(component)[0]
                    atom = molecule.get_atom_by_id(atom_id)
                    if atom:
                        smarts_parts.append(atom.to_smarts())
                else:
                    # Ïó∞Í≤∞Îêú Î∂ÑÏûê Î∂ÄÎ∂Ñ
                    subgraph = graph.subgraph(component)
                    smarts = self._generate_smarts_from_subgraph(subgraph, molecule)
                    if smarts:
                        smarts_parts.append(smarts)

            # Ïó¨Îü¨ Ïª¥Ìè¨ÎÑåÌä∏Î•º Ï†ê(.)ÏúºÎ°ú Ïó∞Í≤∞
            return ".".join(smarts_parts)

        except Exception as e:
            st.error(f"SMARTS ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {str(e)}")
            return ""

    def _generate_smarts_from_subgraph(self, subgraph: nx.Graph, molecule: Molecule) -> str:
        """ÏÑúÎ∏åÍ∑∏ÎûòÌîÑÏóêÏÑú SMARTS ÏÉùÏÑ±"""
        if len(subgraph.nodes()) == 0:
            return ""

        # ÏãúÏûë ÏõêÏûê ÏÑ†ÌÉù (ÎèÑÏàòÍ∞Ä Í∞ÄÏû• ÎÇÆÏùÄ ÏõêÏûêÎ∂ÄÌÑ∞)
        start_atom = min(subgraph.nodes(), key=lambda x: subgraph.degree(x))

        # DFSÎ°ú SMARTS Î¨∏ÏûêÏó¥ Íµ¨ÏÑ±
        visited = set()
        ring_closures = {}
        ring_counter = 1

        def dfs_smarts(atom_id: int, parent_id: Optional[int] = None) -> str:
            nonlocal ring_counter

            if atom_id in visited:
                # Í≥†Î¶¨ Îã´Ìûò Ï≤òÎ¶¨
                if atom_id not in ring_closures:
                    ring_closures[atom_id] = ring_counter
                    ring_counter += 1
                return str(ring_closures[atom_id])

            visited.add(atom_id)
            atom = molecule.get_atom_by_id(atom_id)
            if not atom:
                return ""

            # ÏõêÏûê SMARTS
            atom_smarts = atom.to_smarts()

            # Ïó∞Í≤∞Îêú ÏõêÏûêÎì§ Ï≤òÎ¶¨
            neighbors = list(subgraph.neighbors(atom_id))
            if parent_id:
                neighbors = [n for n in neighbors if n != parent_id]

            # Í≤∞Ìï©Í≥º ÏõêÏûê Ï∂îÍ∞Ä
            branches = []
            for neighbor_id in neighbors:
                # Í≤∞Ìï© SMARTS
                bond = self._find_bond_between_atoms(molecule, atom_id, neighbor_id)
                bond_smarts = bond.to_smarts() if bond else ""

                # Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Ïù¥ÏõÉ ÏõêÏûê Ï≤òÎ¶¨
                neighbor_smarts = dfs_smarts(neighbor_id, atom_id)

                if neighbor_smarts:
                    full_branch = bond_smarts + neighbor_smarts
                    branches.append(full_branch)

            # Î∂ÑÍ∏∞ Ï≤òÎ¶¨
            if len(branches) == 0:
                result = atom_smarts
            elif len(branches) == 1:
                result = atom_smarts + branches[0]
            else:
                # Ïó¨Îü¨ Î∂ÑÍ∏∞Îäî Í¥ÑÌò∏Î°ú Î¨∂Í∏∞
                main_branch = branches[0]
                side_branches = [f"({branch})" for branch in branches[1:]]
                result = atom_smarts + main_branch + "".join(side_branches)

            # Í≥†Î¶¨ Îã´Ìûò Î≤àÌò∏ Ï∂îÍ∞Ä
            if atom_id in ring_closures:
                result += str(ring_closures[atom_id])

            return result

        return dfs_smarts(start_atom)

    def _find_bond_between_atoms(self, molecule: Molecule, atom1_id: int, atom2_id: int) -> Optional[Bond]:
        """Îëê ÏõêÏûê ÏÇ¨Ïù¥Ïùò Í≤∞Ìï© Ï∞æÍ∏∞"""
        for bond in molecule.bonds:
            if ((bond.atom1_id == atom1_id and bond.atom2_id == atom2_id) or
                (bond.atom1_id == atom2_id and bond.atom2_id == atom1_id)):
                return bond
        return None

    def create_smarts_interface(self, molecule: Molecule):
        """SMARTS ÏÉùÏÑ± Ïù∏ÌÑ∞ÌéòÏù¥Ïä§"""
        st.header("üß¨ SMARTS Ìå®ÌÑ¥ ÏÉùÏÑ±")

        col1, col2 = st.columns([2, 1])

        with col1:
            # ÏûêÎèô ÏÉùÏÑ±Îêú SMARTS
            smarts = self.generate_smarts_from_molecule(molecule)

            st.subheader("ÏÉùÏÑ±Îêú SMARTS Ìå®ÌÑ¥")
            smarts_input = st.text_area(
                "SMARTS Ìå®ÌÑ¥:",
                value=smarts,
                height=100,
                help="ÏûêÎèô ÏÉùÏÑ±Îêú SMARTS Ìå®ÌÑ¥ÏûÖÎãàÎã§. ÏßÅÏ†ë ÏàòÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§."
            )

            # Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
            if smarts_input:
                is_valid, message = validate_smarts(smarts_input)
                if is_valid:
                    st.success(f"‚úÖ {message}")
                else:
                    st.error(f"‚ùå {message}")

            # SMARTS Ìå®ÌÑ¥ ÏÑ§Î™Ö
            if smarts_input:
                st.subheader("Ìå®ÌÑ¥ Î∂ÑÏÑù")
                self._explain_smarts_pattern(smarts_input)

        with col2:
            st.subheader("SMARTS ÎèÑÍµ¨")

            # ÏùºÎ∞òÏ†ÅÏù∏ SMARTS Ìå®ÌÑ¥Îì§
            st.write("**ÏûêÏ£º ÏÇ¨Ïö©ÎêòÎäî Ìå®ÌÑ¥:**")

            common_patterns = {
                "ÏûÑÏùò ÏõêÏûê": "*",
                "Î∞©Ìñ•Ï°± ÌÉÑÏÜå": "c",
                "ÏßÄÎ∞©Ï°± ÌÉÑÏÜå": "C",
                "ÎπÑÏàòÏÜå ÏõêÏûê": "[!H]",
                "ÏñëÏ†ÑÌïò": "[+]",
                "ÏùåÏ†ÑÌïò": "[-]",
                "Í≥†Î¶¨ ÎÇ¥ ÏõêÏûê": "[R]",
                "Í≥†Î¶¨ Ïô∏ ÏõêÏûê": "[R0]",
                "1Ï∞® ÌÉÑÏÜå": "[CH3]",
                "2Ï∞® ÌÉÑÏÜå": "[CH2]",
                "3Ï∞® ÌÉÑÏÜå": "[CH]",
                "4Ï∞® ÌÉÑÏÜå": "[C]",
                "Î∞©Ìñ•Ï°± ÏßàÏÜå": "n",
                "ÏßÄÎ∞©Ï°± ÏßàÏÜå": "N",
                "Ïπ¥Î•¥Î≥¥Îãê ÌÉÑÏÜå": "[C]=[O]",
                "ÌïòÏù¥ÎìúÎ°ùÏã§": "[OH]",
                "Ìï†Î°úÍ≤ê": "[F,Cl,Br,I]"
            }

            for name, pattern in common_patterns.items():
                if st.button(f"{name}", key=f"pattern_{name}"):
                    st.session_state['selected_pattern'] = pattern
                    st.info(f"ÏÑ†ÌÉùÎêú Ìå®ÌÑ¥: `{pattern}`")

            # Ìå®ÌÑ¥ Ï°∞Ìï© ÎèÑÍµ¨
            st.write("**Ìå®ÌÑ¥ Ï°∞Ìï©:**")

            if st.button("OR Ï°∞Í±¥ [A,B]"):
                st.info("Ïòà: [C,N] = ÌÉÑÏÜå ÎòêÎäî ÏßàÏÜå")

            if st.button("NOT Ï°∞Í±¥ [!A]"):
                st.info("Ïòà: [!C] = ÌÉÑÏÜåÍ∞Ä ÏïÑÎãå ÏõêÏûê")

            if st.button("AND Ï°∞Í±¥ [A&B]"):
                st.info("Ïòà: [C&R] = Í≥†Î¶¨ ÎÇ¥ ÌÉÑÏÜå")

            # Í≤∞Ìï© Ìå®ÌÑ¥
            st.write("**Í≤∞Ìï© Ìå®ÌÑ¥:**")
            bond_patterns = {
                "Îã®ÏùºÍ≤∞Ìï©": "-",
                "Ïù¥Ï§ëÍ≤∞Ìï©": "=",
                "ÏÇºÏ§ëÍ≤∞Ìï©": "#",
                "Î∞©Ìñ•Ï°±Í≤∞Ìï©": ":",
                "ÏûÑÏùòÍ≤∞Ìï©": "~",
                "Í≥†Î¶¨ÎÇ¥Í≤∞Ìï©": "@",
                "Í≥†Î¶¨Ïô∏Í≤∞Ìï©": "!@"
            }

            for name, pattern in bond_patterns.items():
                if st.button(f"{name}", key=f"bond_{name}"):
                    st.info(f"Í≤∞Ìï© Ìå®ÌÑ¥: `{pattern}`")

        return smarts_input

    def _explain_smarts_pattern(self, smarts: str):
        """SMARTS Ìå®ÌÑ¥ ÏÑ§Î™Ö"""
        try:
            # RDKitÏúºÎ°ú Ìå®ÌÑ¥ ÌååÏã±
            mol = Chem.MolFromSmarts(smarts)
            if mol is None:
                st.warning("Ìå®ÌÑ¥ÏùÑ Î∂ÑÏÑùÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
                return

            # Í∏∞Î≥∏ Ï†ïÎ≥¥
            num_atoms = mol.GetNumAtoms()
            num_bonds = mol.GetNumBonds()

            st.write(f"**ÏõêÏûê Ïàò:** {num_atoms}")
            st.write(f"**Í≤∞Ìï© Ïàò:** {num_bonds}")

            # ÏõêÏûêÎ≥Ñ Î∂ÑÏÑù
            if num_atoms > 0:
                st.write("**ÏõêÏûê Î∂ÑÏÑù:**")
                for i, atom in enumerate(mol.GetAtoms()):
                    atom_info = []

                    # ÏõêÏÜå
                    if atom.GetAtomicNum() != 0:
                        atom_info.append(f"ÏõêÏÜå: {atom.GetSymbol()}")
                    else:
                        atom_info.append("ÏûÑÏùò ÏõêÏûê")

                    # Î∞©Ìñ•Ï°±ÏÑ±
                    if atom.GetIsAromatic():
                        atom_info.append("Î∞©Ìñ•Ï°±")

                    # Ï†ÑÌïò
                    if atom.GetFormalCharge() != 0:
                        atom_info.append(f"Ï†ÑÌïò: {atom.GetFormalCharge():+d}")

                    # ÏàòÏÜå Í∞úÏàò
                    if atom.GetTotalNumHs() > 0:
                        atom_info.append(f"ÏàòÏÜå: {atom.GetTotalNumHs()}")

                    st.write(f"  ÏõêÏûê {i+1}: {', '.join(atom_info)}")

            # Í≤∞Ìï©Î≥Ñ Î∂ÑÏÑù
            if num_bonds > 0:
                st.write("**Í≤∞Ìï© Î∂ÑÏÑù:**")
                for i, bond in enumerate(mol.GetBonds()):
                    bond_info = []

                    # Í≤∞Ìï© ÌÉÄÏûÖ
                    bond_type = bond.GetBondType()
                    if bond_type == Chem.BondType.SINGLE:
                        bond_info.append("Îã®ÏùºÍ≤∞Ìï©")
                    elif bond_type == Chem.BondType.DOUBLE:
                        bond_info.append("Ïù¥Ï§ëÍ≤∞Ìï©")
                    elif bond_type == Chem.BondType.TRIPLE:
                        bond_info.append("ÏÇºÏ§ëÍ≤∞Ìï©")
                    elif bond_type == Chem.BondType.AROMATIC:
                        bond_info.append("Î∞©Ìñ•Ï°±Í≤∞Ìï©")

                    # Ïó∞Í≤∞Îêú ÏõêÏûê
                    atom1_idx = bond.GetBeginAtomIdx()
                    atom2_idx = bond.GetEndAtomIdx()
                    bond_info.append(f"ÏõêÏûê {atom1_idx+1}-{atom2_idx+1}")

                    st.write(f"  Í≤∞Ìï© {i+1}: {', '.join(bond_info)}")

        except Exception as e:
            st.warning(f"Ìå®ÌÑ¥ Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {str(e)}")

    def create_pattern_library_interface(self):
        """Ìå®ÌÑ¥ ÎùºÏù¥Î∏åÎü¨Î¶¨ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§"""
        st.header("üìö SMARTS Ìå®ÌÑ¥ ÎùºÏù¥Î∏åÎü¨Î¶¨")

        # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ìå®ÌÑ¥
        categories = {
            "Í∏∞Î≥∏ ÏõêÏûê Ìå®ÌÑ¥": {
                "ÏûÑÏùò ÏõêÏûê": "*",
                "ÌÉÑÏÜå": "C",
                "ÏßàÏÜå": "N",
                "ÏÇ∞ÏÜå": "O",
                "Ìô©": "S",
                "Ïù∏": "P",
                "Ìï†Î°úÍ≤ê": "[F,Cl,Br,I]",
                "ÎπÑÏàòÏÜå": "[!H]",
                "Î∞©Ìñ•Ï°± ÌÉÑÏÜå": "c",
                "ÏßÄÎ∞©Ï°± ÌÉÑÏÜå": "C"
            },
            "Ï†ÑÌïò Ìå®ÌÑ¥": {
                "ÏñëÏ†ÑÌïò": "[+]",
                "ÏùåÏ†ÑÌïò": "[-]",
                "+1 Ï†ÑÌïò": "[+1]",
                "-1 Ï†ÑÌïò": "[-1]",
                "Ï§ëÏÑ±": "[+0]"
            },
            "ÏàòÏÜå Ìå®ÌÑ¥": {
                "ÏàòÏÜå ÏóÜÏùå": "[H0]",
                "ÏàòÏÜå 1Í∞ú": "[H1]",
                "ÏàòÏÜå 2Í∞ú": "[H2]",
                "ÏàòÏÜå 3Í∞ú": "[H3]",
                "ÏàòÏÜå ÏûàÏùå": "[H]"
            },
            "Í≥†Î¶¨ Ìå®ÌÑ¥": {
                "Í≥†Î¶¨ ÎÇ¥": "[R]",
                "Í≥†Î¶¨ Ïô∏": "[R0]",
                "5ÏõêÌôò": "[R1]",
                "6ÏõêÌôò": "[R2]",
                "Î∞©Ìñ•Ï°± Í≥†Î¶¨": "[r6]"
            },
            "ÏûëÏö©Í∏∞ Ìå®ÌÑ¥": {
                "ÌïòÏù¥ÎìúÎ°ùÏã§": "[OH]",
                "Ïπ¥Î•¥Î≥¥Îãê": "C=O",
                "Ïπ¥Î•¥Î≥µÏã§": "C(=O)O",
                "ÏóêÏä§ÌÖåÎ•¥": "C(=O)O[!H]",
                "ÏïÑÎØ∏Îìú": "C(=O)N",
                "ÎãàÌä∏Î°ú": "[N+](=O)[O-]",
                "Ïà†Ìè∞ÏÇ∞": "S(=O)(=O)O",
                "ÏïÑÎØ∏ÎÖ∏": "N[!H]",
                "ÏïåÎç∞ÌûàÎìú": "C(=O)[H]",
                "ÏºÄÌÜ§": "C(=O)[!H]",
                "ÏóêÌÖåÎ•¥": "O([!H])[!H]",
                "Ìã∞Ïò¨": "[SH]"
            },
            "Í≤∞Ìï© Ìå®ÌÑ¥": {
                "Îã®ÏùºÍ≤∞Ìï©": "-",
                "Ïù¥Ï§ëÍ≤∞Ìï©": "=",
                "ÏÇºÏ§ëÍ≤∞Ìï©": "#",
                "Î∞©Ìñ•Ï°±Í≤∞Ìï©": ":",
                "ÏûÑÏùòÍ≤∞Ìï©": "~",
                "Í≥†Î¶¨ÎÇ¥Í≤∞Ìï©": "@",
                "Í≥†Î¶¨Ïô∏Í≤∞Ìï©": "!@"
            }
        }

        # Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù
        selected_category = st.selectbox(
            "Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù:",
            list(categories.keys())
        )

        # ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Ìå®ÌÑ¥Îì§ ÌëúÏãú
        if selected_category:
            patterns = categories[selected_category]

            st.subheader(f"{selected_category}")

            # Ìå®ÌÑ¥ÏùÑ Ìëú ÌòïÌÉúÎ°ú ÌëúÏãú
            for name, pattern in patterns.items():
                col1, col2, col3 = st.columns([2, 2, 1])

                with col1:
                    st.write(f"**{name}**")

                with col2:
                    st.code(pattern)

                with col3:
                    if st.button("ÏÇ¨Ïö©", key=f"use_{name}"):
                        st.session_state['selected_pattern'] = pattern
                        st.success(f"'{pattern}' Ìå®ÌÑ¥Ïù¥ ÏÑ†ÌÉùÎêòÏóàÏäµÎãàÎã§!")

        # ÏÇ¨Ïö©Ïûê Ï†ïÏùò Ìå®ÌÑ¥ Ï†ÄÏû•
        st.subheader("ÏÇ¨Ïö©Ïûê Ï†ïÏùò Ìå®ÌÑ¥")

        with st.expander("ÏÉà Ìå®ÌÑ¥ Ï∂îÍ∞Ä"):
            pattern_name = st.text_input("Ìå®ÌÑ¥ Ïù¥Î¶Ñ:")
            pattern_smarts = st.text_input("SMARTS Ìå®ÌÑ¥:")
            pattern_description = st.text_area("ÏÑ§Î™Ö:")

            if st.button("Ìå®ÌÑ¥ Ï†ÄÏû•"):
                if pattern_name and pattern_smarts:
                    # ÏÑ∏ÏÖò ÏÉÅÌÉúÏóê ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥ Ï†ÄÏû•
                    if 'user_patterns' not in st.session_state:
                        st.session_state.user_patterns = {}

                    st.session_state.user_patterns[pattern_name] = {
                        'smarts': pattern_smarts,
                        'description': pattern_description
                    }

                    st.success(f"Ìå®ÌÑ¥ '{pattern_name}'Ïù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!")
                else:
                    st.error("Ìå®ÌÑ¥ Ïù¥Î¶ÑÍ≥º SMARTSÎ•º Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.")

        # Ï†ÄÏû•Îêú ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥ ÌëúÏãú
        if 'user_patterns' in st.session_state and st.session_state.user_patterns:
            st.subheader("Ï†ÄÏû•Îêú ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥")

            for name, data in st.session_state.user_patterns.items():
                with st.expander(f"üìå {name}"):
                    st.code(data['smarts'])
                    if data['description']:
                        st.write(data['description'])

                    col1, col2 = st.columns(2)
                    with col1:
                        if st.button("ÏÇ¨Ïö©", key=f"user_use_{name}"):
                            st.session_state['selected_pattern'] = data['smarts']
                            st.success(f"'{data['smarts']}' Ìå®ÌÑ¥Ïù¥ ÏÑ†ÌÉùÎêòÏóàÏäµÎãàÎã§!")

                    with col2:
                        if st.button("ÏÇ≠Ï†ú", key=f"user_delete_{name}"):
                            del st.session_state.user_patterns[name]
                            st.success(f"Ìå®ÌÑ¥ '{name}'Ïù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!")
                            st.rerun()